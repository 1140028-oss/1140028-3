<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>迷宮遊戲</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            touch-action: none; /* 防止在觸控設備上滾動 */
        }
        canvas {
            background-color: #1a202c; /* 深色背景，突顯迷宮 */
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        /* 自定義按鈕樣式 */
        .btn {
            display: inline-block;
            font-weight: 500;
            color: #ffffff;
            background-color: #4f46e5;
            text-align: center;
            vertical-align: middle;
            cursor: pointer;
            border: 1px solid transparent;
            padding: 0.75rem 1.5rem;
            font-size: 1rem;
            border-radius: 0.5rem;
            transition: background-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }
        .btn:hover {
            background-color: #4338ca;
        }
        .btn:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(129, 140, 248, 0.5);
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl text-center">
        <h1 class="text-4xl md:text-5xl font-bold mb-2 text-indigo-400">迷宮挑戰</h1>
        <p class="text-lg md:text-xl mb-6 text-gray-300">使用 <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">方向鍵</kbd> 或 <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">WASD</kbd> 移動小人，避開陷阱並抵達傳送門！</p>

        <!-- 遊戲畫布 -->
        <div class="relative inline-block">
            <canvas id="mazeCanvas"></canvas>
            <!-- 勝利訊息 -->
            <div id="winMessage" class="absolute inset-0 bg-black bg-opacity-75 flex-col items-center justify-center rounded-lg hidden">
                <h2 class="text-5xl font-bold text-green-400 mb-4">恭喜！</h2>
                <p class="text-2xl text-white">你成功逃脫了！</p>
            </div>
             <!-- 遊戲結束訊息 -->
            <div id="gameOverMessage" class="absolute inset-0 bg-black bg-opacity-75 flex-col items-center justify-center rounded-lg hidden">
                <h2 class="text-5xl font-bold text-red-500 mb-4">遊戲結束！</h2>
                <p class="text-2xl text-white">你踩到陷阱了！</p>
            </div>
        </div>


        <div class="mt-6">
            <button id="resetButton" class="btn">產生新迷宮</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const winMessage = document.getElementById('winMessage');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const resetButton = document.getElementById('resetButton');

        // --- 遊戲設定 ---
        let maze, player, exit, traps;
        let gameOver = false;
        const mazeSize = 21; // 迷宮大小 (必須是奇數)
        let cellSize; // 每個格子的像素大小

        // --- 顏色設定 ---
        const WALL_COLOR = '#4a5568';
        const PATH_COLOR = '#1a202c';
        const PLAYER_COLOR = '#6366f1';
        const TRAP_COLOR = '#ef4444'; // 陷阱顏色

        /**
         * 調整畫布大小以適應螢幕
         */
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, window.innerHeight * 0.65);
            canvas.width = size;
            canvas.height = size;
            cellSize = canvas.width / mazeSize;
        }

        /**
         * 產生迷宮的函數
         */
        function generateMaze(width, height) {
            maze = Array.from({ length: height }, () => Array(width).fill(1));
            const stack = [[1, 1]];
            maze[1][1] = 0;

            while (stack.length > 0) {
                const [cx, cy] = stack[stack.length - 1];
                const neighbors = [];
                const directions = [[2, 0, 1, 0], [-2, 0, -1, 0], [0, 2, 0, 1], [0, -2, 0, -1]];
                for (const [dx, dy, wx, wy] of directions) {
                    const nx = cx + dx, ny = cy + dy;
                    if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                        neighbors.push([nx, ny, cx + wx, cy + wy]);
                    }
                }
                if (neighbors.length > 0) {
                    const [nx, ny, wallX, wallY] = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[wallY][wallX] = 0;
                    maze[ny][nx] = 0;
                    stack.push([nx, ny]);
                } else {
                    stack.pop();
                }
            }
        }
        
        /**
         * 繪製整個迷宮
         */
        function drawMaze() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    ctx.fillStyle = maze[y][x] === 1 ? WALL_COLOR : PATH_COLOR;
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }

            // 繪製出口 (傳送門)
            const centerX = exit.x * cellSize + cellSize / 2;
            const centerY = exit.y * cellSize + cellSize / 2;
            const outerRadius = cellSize * 0.45;
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, outerRadius);
            gradient.addColorStop(0, '#f0abfc');
            gradient.addColorStop(0.6, '#a855f7');
            gradient.addColorStop(1, '#581c87');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, outerRadius, 0, 2 * Math.PI);
            ctx.fill();

            // 繪製陷阱
            ctx.strokeStyle = TRAP_COLOR;
            ctx.lineWidth = Math.max(1, cellSize * 0.1); // 陷阱線條寬度
            for (const trap of traps) {
                const trapX = trap.x * cellSize;
                const trapY = trap.y * cellSize;
                const padding = cellSize * 0.25;
                ctx.beginPath();
                ctx.moveTo(trapX + padding, trapY + padding);
                ctx.lineTo(trapX + cellSize - padding, trapY + cellSize - padding);
                ctx.moveTo(trapX + cellSize - padding, trapY + padding);
                ctx.lineTo(trapX + padding, trapY + cellSize - padding);
                ctx.stroke();
            }

            // 繪製玩家 (小人)
            ctx.fillStyle = PLAYER_COLOR;
            const playerPixelX = player.x * cellSize;
            const playerPixelY = player.y * cellSize;
            const headRadius = cellSize * 0.2;
            const headX = playerPixelX + cellSize / 2;
            const headY = playerPixelY + headRadius + (cellSize * 0.1);
            const bodyWidth = cellSize * 0.4;
            const bodyHeight = cellSize * 0.4;
            const bodyX = playerPixelX + (cellSize - bodyWidth) / 2;
            const bodyY = headY + headRadius - (cellSize * 0.05);
            ctx.beginPath();
            ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillRect(bodyX, bodyY, bodyWidth, bodyHeight);
        }

        /**
         * 處理遊戲結束
         */
        function triggerGameOver() {
            gameOver = true;
            gameOverMessage.classList.remove('hidden');
            gameOverMessage.classList.add('flex');
        }
        
        /**
         * 處理鍵盤輸入
         */
        function handleKeyDown(e) {
            if (gameOver || (player.x === exit.x && player.y === exit.y)) return;
            let dx = 0, dy = 0;
            switch (e.key) {
                case 'ArrowUp': case 'w': dy = -1; break;
                case 'ArrowDown': case 's': dy = 1; break;
                case 'ArrowLeft': case 'a': dx = -1; break;
                case 'ArrowRight': case 'd': dx = 1; break;
                default: return;
            }
            e.preventDefault();
            const nextX = player.x + dx;
            const nextY = player.y + dy;
            if (maze[nextY] && maze[nextY][nextX] === 0) {
                player.x = nextX;
                player.y = nextY;
                if (traps.some(trap => trap.x === player.x && trap.y === player.y)) {
                    triggerGameOver();
                } else if (player.x === exit.x && player.y === exit.y) {
                    winMessage.classList.remove('hidden');
                    winMessage.classList.add('flex');
                }
                drawMaze();
            }
        }

        /**
         * 初始化或重置遊戲
         */
        function init() {
            gameOver = false;
            winMessage.classList.add('hidden');
            gameOverMessage.classList.add('hidden');
            traps = [];
            
            resizeCanvas();
            generateMaze(mazeSize, mazeSize);

            player = { x: 1, y: 1 };
            exit = { x: mazeSize - 2, y: mazeSize - 2 };
            maze[exit.y][exit.x] = 0;

            // 找出所有死路
            const deadEnds = [];
            const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]];
            for (let y = 1; y < mazeSize - 1; y++) {
                for (let x = 1; x < mazeSize - 1; x++) {
                    if (maze[y][x] === 0) { // 必須是路徑
                        let wallCount = 0;
                        for (const [dx, dy] of directions) {
                            if (maze[y + dy][x + dx] === 1) {
                                wallCount++;
                            }
                        }
                        
                        // 死路 = 3面是牆
                        if (wallCount === 3) {
                            // 確保不是起點或終點
                            if (!((x === 1 && y === 1) || (x === exit.x && y === exit.y))) {
                                deadEnds.push({ x, y });
                            }
                        }
                    }
                }
            }

            // 隨機選取 50% 的死路作為陷阱
            const TRAP_PERCENTAGE = 0.5;
            deadEnds.sort(() => 0.5 - Math.random());
            traps = deadEnds.slice(0, Math.floor(deadEnds.length * TRAP_PERCENTAGE));

            drawMaze();
        }

        // --- 事件監聽 ---
        document.addEventListener('keydown', handleKeyDown);
        resetButton.addEventListener('click', init);
        window.addEventListener('resize', () => {
            setTimeout(() => {
                resizeCanvas();
                drawMaze();
            }, 100);
        });

        // 首次啟動遊戲
        init();
    </script>
</body>
</html>


